---
interface DataSeries {
  name: string;
  data: { label: string; value: number }[];
  color?: string;
}

interface Props {
  series: DataSeries[];
  title?: string;
  width?: number;
  height?: number;
  showPoints?: boolean;
  showArea?: boolean;
  curved?: boolean;
  unit?: string;
}

const {
  series,
  title,
  width = 600,
  height = 300,
  showPoints = true,
  showArea = true,
  curved = true,
  unit = '',
} = Astro.props;

const padding = { top: 30, right: 20, bottom: 50, left: 50 };
const chartWidth = width - padding.left - padding.right;
const chartHeight = height - padding.top - padding.bottom;

// Parse label for sorting - handles "S1", "S2" (weeks) or "13 ene" (dates)
const parseLabelForSort = (label: string): number => {
  // Week format: "S1", "S2", etc.
  if (label.startsWith('S') && !isNaN(parseInt(label.slice(1)))) {
    return parseInt(label.slice(1));
  }

  // Date format: "13 ene"
  const months: Record<string, number> = {
    'ene': 0, 'feb': 1, 'mar': 2, 'abr': 3, 'may': 4, 'jun': 5,
    'jul': 6, 'ago': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dic': 11
  };
  const parts = label.toLowerCase().split(' ');
  const day = parseInt(parts[0]);
  const month = months[parts[1]] ?? 0;
  const year = new Date().getFullYear();
  return new Date(year, month, day).getTime();
};

const allLabels = [...new Set(series.flatMap((s) => s.data.map((d) => d.label)))]
  .sort((a, b) => parseLabelForSort(a) - parseLabelForSort(b));
const allValues = series.flatMap((s) => s.data.map((d) => d.value));
const maxValue = Math.max(...allValues);
const minValue = Math.min(0, ...allValues);
const valueRange = maxValue - minValue || 1;

const chartId = `line-${Math.random().toString(36).substr(2, 9)}`;

const themeColors = ['#30d158', '#ff9500', '#ff3b30', '#ffffff'];

const scaleX = (index: number) => (index / (allLabels.length - 1 || 1)) * chartWidth;
const scaleY = (value: number) => chartHeight - ((value - minValue) / valueRange) * chartHeight;

const generatePath = (data: { label: string; value: number }[]) => {
  const points = data.map((d) => {
    const labelIndex = allLabels.indexOf(d.label);
    return { x: scaleX(labelIndex), y: scaleY(d.value) };
  });

  if (curved && points.length > 2) {
    let path = `M ${points[0].x} ${points[0].y}`;
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[Math.max(0, i - 1)];
      const p1 = points[i];
      const p2 = points[i + 1];
      const p3 = points[Math.min(points.length - 1, i + 2)];
      const cp1x = p1.x + (p2.x - p0.x) / 6;
      const cp1y = p1.y + (p2.y - p0.y) / 6;
      const cp2x = p2.x - (p3.x - p1.x) / 6;
      const cp2y = p2.y - (p3.y - p1.y) / 6;
      path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
    }
    return path;
  } else {
    return points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
  }
};

const generateAreaPath = (data: { label: string; value: number }[]) => {
  const linePath = generatePath(data);
  const lastIndex = allLabels.indexOf(data[data.length - 1].label);
  const firstIndex = allLabels.indexOf(data[0].label);
  return `${linePath} L ${scaleX(lastIndex)} ${chartHeight} L ${scaleX(firstIndex)} ${chartHeight} Z`;
};

const tickCount = 4;
const tickStep = valueRange / tickCount;
const ticks = Array.from({ length: tickCount + 1 }, (_, i) => Math.round(minValue + tickStep * i));

// Pre-calculate data for template
const areaData = showArea ? series.map((s, i) => ({
  path: generateAreaPath(s.data),
  gradId: `${chartId}-grad-${i}`
})) : [];

const lineData = series.map((s, i) => ({
  path: generatePath(s.data),
  color: s.color || themeColors[i % themeColors.length]
}));

const pointsData = showPoints ? series.flatMap((s, i) => {
  const color = s.color || themeColors[i % themeColors.length];
  return s.data.map((d) => {
    const labelIndex = allLabels.indexOf(d.label);
    return {
      cx: scaleX(labelIndex),
      cy: scaleY(d.value),
      color,
      seriesName: s.name,
      label: d.label,
      value: d.value
    };
  });
}) : [];

const tickData = ticks.map((tick) => ({
  y: scaleY(tick),
  label: `${tick}${unit}`
}));

const xLabelData = allLabels
  .map((label, i) => ({ label, x: scaleX(i), show: allLabels.length <= 7 || i % Math.ceil(allLabels.length / 7) === 0 }))
  .filter(d => d.show);

const showLegend = series.length > 1;
const legendData = showLegend ? series.map((s, i) => ({
  color: s.color || themeColors[i % themeColors.length],
  name: s.name,
  shortName: s.name.length > 25 ? s.name.substring(0, 25) + '...' : s.name,
  xOffset: i * 150
})) : [];

const gradients = series.map((s, i) => ({
  id: `${chartId}-grad-${i}`,
  color: s.color || themeColors[i % themeColors.length]
}));
---

<div class="chart-wrapper">
  {title && <div class="chart-title">{title}</div>}

  {showLegend && (
    <div class="legend-wrapper">
      {legendData.map((l) => (
        <div class="legend-item-html" title={l.name} data-exercise-name={l.name} role="button" tabindex="0">
          <span class="legend-dot" style={`background: ${l.color}`}></span>
          <span class="legend-label">{l.shortName}</span>
        </div>
      ))}
    </div>
  )}

  <svg id={chartId} viewBox={`0 0 ${width} ${height}`} class="line-chart">
    <defs>
      {gradients.map((g) => (
        <linearGradient id={g.id} x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stop-color={g.color} stop-opacity="0.25" />
          <stop offset="100%" stop-color={g.color} stop-opacity="0" />
        </linearGradient>
      ))}
    </defs>

    <g transform={`translate(${padding.left}, ${padding.top})`}>
      {tickData.map((t) => (
        <line x1={0} y1={t.y} x2={chartWidth} y2={t.y} class="grid-line" />
      ))}

      {areaData.map((a) => (
        <path d={a.path} fill={`url(#${a.gradId})`} class="area-path" />
      ))}

      {lineData.map((l) => (
        <path d={l.path} fill="none" stroke={l.color} stroke-width="2" stroke-linecap="round" class="line-path" />
      ))}

      {pointsData.map((p) => (
        <circle
          cx={p.cx}
          cy={p.cy}
          r="4"
          fill="#0a0a0a"
          stroke={p.color}
          stroke-width="2"
          class="data-point"
          data-series={p.seriesName}
          data-label={p.label}
          data-value={p.value}
        />
      ))}

      {tickData.map((t) => (
        <text x={-8} y={t.y} class="axis-label" text-anchor="end" dominant-baseline="middle">
          {t.label}
        </text>
      ))}

      {xLabelData.map((d) => (
        <text x={d.x} y={chartHeight + 20} class="axis-label" text-anchor="middle">
          {d.label}
        </text>
      ))}
    </g>

    <g id={`${chartId}-tip`} class="tooltip" visibility="hidden">
      <rect x="0" y="0" width="160" height="54" rx="4" />
      <text x="8" y="14" class="tip-label"></text>
      <text x="8" y="30" class="tip-date"></text>
      <text x="8" y="46" class="tip-value"></text>
    </g>
  </svg>
</div>

<script define:vars={{ chartId, unit, width, height, padding }}>
  const svg = document.getElementById(chartId);
  const tooltip = document.getElementById(`${chartId}-tip`);

  if (svg && tooltip) {
    const points = svg.querySelectorAll('.data-point');
    const tooltipWidth = 160;
    const tooltipHeight = 54;
    const chartLeft = padding.left;
    const chartRight = width - padding.right;
    const chartTop = padding.top;
    const chartBottom = height - padding.bottom;

    // Truncate text to fit tooltip width
    const truncateText = (text, maxChars = 20) => {
      if (text.length > maxChars) {
        return text.substring(0, maxChars - 1) + 'â€¦';
      }
      return text;
    };

    points.forEach((point) => {
      point.addEventListener('mouseenter', (e) => {
        const t = e.target;
        const label = t.getAttribute('data-label');
        const value = t.getAttribute('data-value');
        const series = t.getAttribute('data-series');

        tooltip.querySelector('.tip-label').textContent = truncateText(series || 'Ejercicio', 22);
        tooltip.querySelector('.tip-date').textContent = label;
        tooltip.querySelector('.tip-value').textContent = value + unit;

        const pointCx = parseFloat(t.getAttribute('cx')) + chartLeft;
        const pointCy = parseFloat(t.getAttribute('cy')) + chartTop;

        // Default position: to the right and below the point
        let tipX = pointCx + 10;
        let tipY = pointCy + 10;

        // Check if tooltip would overflow right edge
        if (tipX + tooltipWidth > width - 10) {
          tipX = pointCx - tooltipWidth - 10;
        }

        // Check if tooltip would overflow bottom edge
        if (tipY + tooltipHeight > height - 10) {
          tipY = pointCy - tooltipHeight - 10;
        }

        // Ensure tooltip doesn't go past left edge
        if (tipX < 10) {
          tipX = 10;
        }

        // Ensure tooltip doesn't go past top edge
        if (tipY < 10) {
          tipY = 10;
        }

        tooltip.setAttribute('transform', `translate(${tipX}, ${tipY})`);
        tooltip.setAttribute('visibility', 'visible');
        t.setAttribute('r', '6');
      });

      point.addEventListener('mouseleave', (e) => {
        tooltip.setAttribute('visibility', 'hidden');
        e.target.setAttribute('r', '4');
      });
    });
  }
</script>

<style>
  .chart-wrapper {
    background: var(--bg-card, #0f0f0f);
    border: 1px solid var(--border, #2a2a2a);
    border-radius: 12px;
    padding: 1.25rem;
  }

  .chart-title {
    font-family: var(--font-display, 'Orbitron', sans-serif);
    font-size: 0.7rem;
    color: var(--text-muted, #606060);
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 1rem;
  }

  .line-chart {
    width: 100%;
    height: auto;
    display: block;
  }

  .grid-line {
    stroke: var(--border, #2a2a2a);
    stroke-width: 1;
  }

  .line-path {
    filter: drop-shadow(0 0 4px currentColor);
  }

  .area-path {
    opacity: 0.8;
  }

  .data-point {
    cursor: pointer;
    transition: r 0.15s ease;
  }

  .axis-label {
    font-family: var(--font-body, 'Space Grotesk', monospace);
    font-size: 10px;
    fill: var(--text-muted, #606060);
  }

  .legend-wrapper {
    display: flex;
    gap: var(--space-3, 0.75rem);
    flex-wrap: wrap;
    margin-bottom: var(--space-4, 1rem);
    padding: var(--space-2, 0.5rem) 0;
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border, #2a2a2a) transparent;
  }

  .legend-wrapper::-webkit-scrollbar {
    height: 4px;
  }

  .legend-wrapper::-webkit-scrollbar-track {
    background: transparent;
  }

  .legend-wrapper::-webkit-scrollbar-thumb {
    background: var(--border, #2a2a2a);
    border-radius: 2px;
  }

  .legend-wrapper::-webkit-scrollbar-thumb:hover {
    background: var(--border-light, #333);
  }

  .legend-item-html {
    display: flex;
    align-items: center;
    gap: var(--space-2, 0.5rem);
    padding: var(--space-1, 0.25rem) var(--space-2, 0.5rem);
    background: var(--bg-secondary, #121212);
    border: 1px solid var(--border, #2a2a2a);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s ease;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .legend-item-html:hover {
    border-color: var(--accent-green, #30d158);
    background: var(--bg-tertiary, #1a1a1a);
  }

  .legend-item-html:focus {
    outline: none;
    border-color: var(--accent-green, #30d158);
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .legend-label {
    font-family: var(--font-body, 'Space Grotesk', monospace);
    font-size: 0.7rem;
    color: var(--text-secondary, #a0a0a0);
    letter-spacing: 0.5px;
  }

  .legend-item-html:hover .legend-label {
    color: var(--text-primary, #ffffff);
  }

  .tooltip rect {
    fill: var(--bg-tertiary, #1a1a1a);
    stroke: var(--border-light, #333);
  }

  .tip-label {
    font-family: var(--font-body, 'Space Grotesk', monospace);
    font-size: 9px;
    fill: var(--text-secondary, #a0a0a0);
  }

  .tip-date {
    font-family: var(--font-body, 'Space Grotesk', monospace);
    font-size: 9px;
    fill: var(--text-muted, #606060);
  }

  .tip-value {
    font-family: var(--font-display, 'Orbitron', sans-serif);
    font-size: 13px;
    fill: var(--text-primary, #ffffff);
  }
</style>
